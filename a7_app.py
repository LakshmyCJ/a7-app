# -*- coding: utf-8 -*-
"""A7 app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E80bcXbsGlbT32b9RxK71RYK7n-9gZCK
"""
#pip install --upgrade pip
#!pip install streamlit yfinance pandas plotly pypfopt 
import streamlit as st
import yfinance as yf
import pandas as pd
import plotly.express as px
import datetime
from pypfopt import EfficientFrontier, risk_models, expected_returns
import requests
import io

# URL to the CSV file
CSV_URL = "https://raw.githubusercontent.com/yekahaaagayeham/stocks-listed-on-nifty-500-july-2021/main/ind_nifty500list.csv"

@st.cache_data
def load_nifty_500():
    # Download the CSV file content
    response = requests.get(CSV_URL)

    # Decode the content and create a file-like object
    decoded_content = response.content.decode('utf-8')
    file_like_object = io.StringIO(decoded_content)

    # Read the CSV from the file-like object, skipping bad lines
    df = pd.read_csv(file_like_object, on_bad_lines='skip', sep=',')
    return df

nifty_500_df = load_nifty_500()

# Create a dictionary for user-friendly names to tickers
company_dict = dict(zip(nifty_500_df['Company Name'], nifty_500_df['Symbol']))

st.title("Investment Recommendation App: Plan Your Financial Future")

# User inputs
salary = st.number_input("Enter your monthly salary:", min_value=0, key="salary")
savings_percent = st.slider("What percentage of your salary would you like to save?", 0, 100, 20, key="savings_percent")
st.write("Saving consistently is key to building wealth. This slider helps you determine how much you can allocate towards savings.")
savings_amount = salary * (savings_percent / 100)
investment_amount = salary - savings_amount

st.write(f"Your estimated monthly savings amount: ₹{savings_amount:.2f}")
st.write(f"Amount available for investment after savings: ₹{investment_amount:.2f}")

# Drop down to select companies
selected_companies = st.multiselect("Select companies to include in the portfolio:", list(company_dict.keys()), max_selections=10)
tickers = [company_dict[company] for company in selected_companies]

@st.cache_data
def get_stock_data(tickers):
    today = datetime.date.today()
    start_date = today - datetime.timedelta(days=730)  # Get data from the last 2 years
    data = {}
    for ticker in tickers:
        try:
            df = yf.download(ticker, start=start_date.strftime('%Y-%m-%d'), end=today.strftime('%Y-%m-%d'))
            if not df.empty:
                data[ticker] = df['Adj Close']
        except Exception as e:
            st.error(f"Error fetching data for {ticker}: {e}")
    return pd.DataFrame(data)

# Load stock data
stock_data = get_stock_data(tickers)

if stock_data.empty:
    st.warning("No data available for the selected companies.")
else:
    # Calculate daily returns
    returns = stock_data.pct_change().dropna()

    # Portfolio Optimization
    st.subheader("Portfolio Optimization")

    # Calculate expected returns and covariance matrix
    mu = expected_returns.mean_historical_return(stock_data)
    S = risk_models.sample_cov(stock_data)

    # Optimize the portfolio
    ef = EfficientFrontier(mu, S)
    weights = ef.max_sharpe()  # Maximize Sharpe Ratio
    cleaned_weights = ef.clean_weights()
    performance = ef.portfolio_performance(verbose=True)

    st.write("Optimized Portfolio Weights:")
    st.write(cleaned_weights)
    st.write(f"Expected annual return: {performance[0]:.2f}")
    st.write(f"Annual volatility: {performance[1]:.2f}")
    st.write(f"Sharpe ratio: {performance[2]:.2f}")

    # Plot stock price trends
    st.subheader("Explore Historical Stock Prices")
    selected_stock = st.selectbox("Select a stock to view its price trend:", tickers)
    if selected_stock in stock_data:
        fig = px.line(stock_data[selected_stock], x=stock_data.index, y=selected_stock, title=f"{selected_stock} Stock Price")
        st.plotly_chart(fig)
    else:
        st.write(f"Data not available for {selected_stock}.")


#!pip freeze > requirements.txt
# Download the requirements.txt file
#from google.colab import files
f#iles.download('requirements.txt')
